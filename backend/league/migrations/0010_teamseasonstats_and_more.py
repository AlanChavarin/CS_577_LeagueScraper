# Generated by Django 4.2.25 on 2025-11-09 00:08

import django.core.validators
from django.db import migrations, models
from django.db.utils import ProgrammingError
import django.db.models.deletion


class CreateModelIfNotExists(migrations.CreateModel):
    """
    Custom CreateModel operation that skips creation when the table already exists.
    Useful for deployments where the schema has been pre-created (e.g., via data imports).
    """

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        model = to_state.apps.get_model(app_label, self.name)
        table_names = schema_editor.connection.introspection.table_names()
        if model._meta.db_table in table_names:
            return
        try:
            super().database_forwards(app_label, schema_editor, from_state, to_state)
        except ProgrammingError as exc:
            if 'already exists' in str(exc):
                # Table already present; continue without raising.
                return
            raise

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        model = from_state.apps.get_model(app_label, self.name)
        table_names = schema_editor.connection.introspection.table_names()
        if model._meta.db_table not in table_names:
            return
        super().database_backwards(app_label, schema_editor, from_state, to_state)


class AddFieldIfNotExists(migrations.AddField):
    """Add a field only when the column is missing."""

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        model = to_state.apps.get_model(app_label, self.model_name)
        table = model._meta.db_table
        if table not in schema_editor.connection.introspection.table_names():
            # Table hasn't been created yet; fall back to default behavior.
            super().database_forwards(app_label, schema_editor, from_state, to_state)
            return

        field = model._meta.get_field(self.name)
        column_name = field.column
        with schema_editor.connection.cursor() as cursor:
            existing_columns = [
                column.name for column in schema_editor.connection.introspection.get_table_description(cursor, table)
            ]
        if column_name in existing_columns:
            return
        super().database_forwards(app_label, schema_editor, from_state, to_state)

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        model = from_state.apps.get_model(app_label, self.model_name)
        table = model._meta.db_table
        if table not in schema_editor.connection.introspection.table_names():
            return

        field = model._meta.get_field(self.name)
        column_name = field.column
        with schema_editor.connection.cursor() as cursor:
            existing_columns = [
                column.name for column in schema_editor.connection.introspection.get_table_description(cursor, table)
            ]
        if column_name not in existing_columns:
            return
        super().database_backwards(app_label, schema_editor, from_state, to_state)


class AddIndexIfNotExists(migrations.AddIndex):
    """Add an index when it doesn't already exist."""

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        model = to_state.apps.get_model(app_label, self.model_name)
        table = model._meta.db_table
        if table not in schema_editor.connection.introspection.table_names():
            super().database_forwards(app_label, schema_editor, from_state, to_state)
            return

        index_name = self.index.name
        with schema_editor.connection.cursor() as cursor:
            constraints = schema_editor.connection.introspection.get_constraints(cursor, table)
        if index_name in constraints:
            return
        super().database_forwards(app_label, schema_editor, from_state, to_state)

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        model = from_state.apps.get_model(app_label, self.model_name)
        table = model._meta.db_table
        if table not in schema_editor.connection.introspection.table_names():
            return

        index_name = self.index.name
        with schema_editor.connection.cursor() as cursor:
            constraints = schema_editor.connection.introspection.get_constraints(cursor, table)
        if index_name not in constraints:
            return
        super().database_backwards(app_label, schema_editor, from_state, to_state)


class AlterUniqueTogetherSafe(migrations.AlterUniqueTogether):
    """Alter unique_together while tolerating pre-existing constraints."""

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        try:
            super().database_forwards(app_label, schema_editor, from_state, to_state)
        except ProgrammingError as exc:
            if 'already exists' in str(exc):
                return
            raise

    def database_backwards(self, app_label, schema_editor, from_state, to_state):
        try:
            super().database_backwards(app_label, schema_editor, from_state, to_state)
        except ProgrammingError as exc:
            if 'does not exist' in str(exc):
                return
            raise


class Migration(migrations.Migration):

    dependencies = [
        ('league', '0009_remove_season_date'),
    ]

    operations = [
        CreateModelIfNotExists(
            name='TeamSeasonStats',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('region', models.CharField(blank=True, help_text='Region code snapshot (e.g., NA, EUW)', max_length=10)),
                ('games', models.PositiveIntegerField(default=0)),
                ('winrate', models.DecimalField(decimal_places=2, default=0.0, help_text='Win rate as a percent (0-100)', max_digits=5, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100.0)])),
                ('kill_death_ratio', models.FloatField(default=0.0, help_text='Kill/Death ratio')),
                ('gpm', models.PositiveIntegerField(default=0, help_text='Gold per minute')),
                ('gdm', models.IntegerField(default=0, help_text='Gold difference per minute')),
                ('game_duration', models.DurationField(blank=True, help_text='Average game duration', null=True)),
                ('kills_per_game', models.FloatField(default=0.0)),
                ('deaths_per_game', models.FloatField(default=0.0)),
                ('towers_killed', models.FloatField(default=0.0)),
                ('towers_lost', models.FloatField(default=0.0)),
                ('first_blood_percent', models.DecimalField(decimal_places=2, default=0.0, help_text='First blood percentage (0-100)', max_digits=5, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100.0)])),
                ('first_tower_percent', models.DecimalField(decimal_places=2, default=0.0, help_text='First tower percentage (0-100)', max_digits=5, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100.0)])),
                ('first_objective_percent', models.DecimalField(decimal_places=2, default=0.0, help_text='First objective secured percentage (FOS%, 0-100)', max_digits=5, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100.0)])),
                ('dragons_per_game', models.FloatField(default=0.0, help_text='Average dragons per game (DRAPG)')),
                ('dragon_control_percent', models.DecimalField(decimal_places=2, default=0.0, help_text='Dragon control rate (DRA%, 0-100)', max_digits=5, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100.0)])),
                ('void_grub_per_game', models.FloatField(default=0.0, help_text='Void grubs per game (VGPG)')),
                ('herald_percent', models.DecimalField(decimal_places=2, default=0.0, help_text='Herald control percentage (HER%, 0-100)', max_digits=5, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100.0)])),
                ('atakhan_percent', models.DecimalField(decimal_places=2, default=0.0, help_text='ATAKHAN control percentage (0-100)', max_digits=5, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100.0)])),
                ('dragons_at_15', models.FloatField(default=0.0, help_text='Dragons per game by 15 minutes (DRA@15)')),
                ('tower_difference_15', models.FloatField(default=0.0, help_text='Tower difference at 15 minutes (TD@15)')),
                ('gold_difference_15', models.IntegerField(default=0, help_text='Gold difference at 15 minutes (GD@15)')),
                ('points_per_game', models.FloatField(default=0.0, help_text='Points per game (PPG)')),
                ('nashors_per_game', models.FloatField(default=0.0, help_text='Barons per game (NASHPG)')),
                ('nashor_percent', models.DecimalField(decimal_places=2, default=0.0, help_text='Baron control percentage (NASH%, 0-100)', max_digits=5, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(100.0)])),
                ('csm', models.FloatField(default=0.0, help_text='Creep score per minute (CSM)')),
                ('dpm', models.PositiveIntegerField(default=0, help_text='Damage per minute (DPM)')),
                ('wards_per_minute', models.FloatField(default=0.0, help_text='Wards per minute (WPM)')),
                ('vision_wards_per_minute', models.FloatField(default=0.0, help_text='Vision wards per minute (VWPM)')),
                ('wards_cleared_per_minute', models.FloatField(default=0.0, help_text='Wards cleared per minute (WCPM)')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'team_season_stats',
                'ordering': ['season', 'team'],
            },
        ),
        AddFieldIfNotExists(
            model_name='teamseasonstats',
            name='season',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='team_stats', to='league.season'),
        ),
        AddFieldIfNotExists(
            model_name='teamseasonstats',
            name='team',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='season_stats', to='league.team'),
        ),
        AddIndexIfNotExists(
            model_name='teamseasonstats',
            index=models.Index(fields=['team', 'season'], name='team_season_team_id_7d4944_idx'),
        ),
        AddIndexIfNotExists(
            model_name='teamseasonstats',
            index=models.Index(fields=['season'], name='team_season_season__01eaeb_idx'),
        ),
        AddIndexIfNotExists(
            model_name='teamseasonstats',
            index=models.Index(fields=['region'], name='team_season_region_b9a8a0_idx'),
        ),
        AlterUniqueTogetherSafe(
            name='teamseasonstats',
            unique_together={('team', 'season')},
        ),
    ]
